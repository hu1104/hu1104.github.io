<hr>
<p>title: yolov5_real<br>date: 2021-07-06 14:12:37<br>tags: </p>
<ul>
<li>加密<br>password: Mike<br>abstract: Welcome to my blog, enter password to read.<br>message: Welcome to my blog, enter password to read.</li>
</ul>
<hr>
<h1 id="数据集准备"><a href="#数据集准备" class="headerlink" title="数据集准备"></a>数据集准备</h1><blockquote>
<p>数据集的树形框架如下：</p>
<p><img src="before.png" alt="数据划分前"></p>
<p>上述data文件夹中：</p>
<ul>
<li>Annotations: 用labelimg标注软件生成的xml文件</li>
<li>images：原始图像所在文件夹（与xml文件名一一对应，除了扩展名不同）</li>
<li>ImageSets: 文件夹创建一个空的Main文件夹，后续存储生成的train.txt和val.txt</li>
<li>split_data.py: 生成ImagesSets/Main文件夹下的train.txt和val.txt,对应训练集和验证集</li>
<li>xml2txt.py：将xml文件转换成txt文件保存至data文件夹下将新创建的labels文件夹</li>
</ul>
</blockquote>
<p>split_data.py</p>
<pre><code>import os
import random

trainval_percent = 0.2  # 可自行进行调节(设置训练和测试的比例是8：2)
train_percent = 1
xmlfilepath = &#39;Annotations&#39;
txtsavepath = &#39;ImageSets\Main&#39;
total_xml = os.listdir(xmlfilepath)

num = len(total_xml)
list = range(num)
tv = int(num * trainval_percent)
tr = int(tv * train_percent)
trainval = random.sample(list, tv)
val = random.sample(trainval, tr)


ftrain = open(&#39;ImageSets/Main/train.txt&#39;, &#39;w&#39;)
fval = open(&#39;ImageSets/Main/val.txt&#39;, &#39;w&#39;)

for i in list:

    name = total_xml[i][:-4] + &#39;\n&#39;
    if i in val:
        fval.write(name)
    else:
        ftrain.write(name)

ftrain.close()
fval.close()
</code></pre>
<p>xml2txt.py</p>
<pre><code>import xml.etree.ElementTree as ET
import pickle
import os
from os import listdir, getcwd
from os.path import join

sets = [&#39;train&#39;, &#39;val&#39;]

classes = [&#39;single&#39;, &#39;cluster&#39;, &#39;impus&#39;, &#39;dubs&#39;]  # 自己训练的类别


def convert(size, box):
    dw = 1. / size[0]
    dh = 1. / size[1]
    x = (box[0] + box[1]) / 2.0
    y = (box[2] + box[3]) / 2.0
    w = box[1] - box[0]
    h = box[3] - box[2]
    x = x * dw
    w = w * dw
    y = y * dh
    h = h * dh
    return (x, y, w, h)


def convert_annotation(image_id):
    in_file = open(&#39;../data/Annotations/%s.xml&#39; % (image_id))  
    out_file = open(&#39;../data/labels/%s.txt&#39; % (image_id), &#39;w&#39;)  
    tree = ET.parse(in_file)
    root = tree.getroot()
    size = root.find(&#39;size&#39;)
    w = int(size.find(&#39;width&#39;).text)
    h = int(size.find(&#39;height&#39;).text)

    for obj in root.iter(&#39;object&#39;):
        difficult = obj.find(&#39;difficult&#39;).text
        cls = obj.find(&#39;name&#39;).text
        if cls not in classes or int(difficult) == 1:
            continue
        cls_id = classes.index(cls)
        xmlbox = obj.find(&#39;bndbox&#39;)
        b = (float(xmlbox.find(&#39;xmin&#39;).text), float(xmlbox.find(&#39;xmax&#39;).text), float(xmlbox.find(&#39;ymin&#39;).text),
             float(xmlbox.find(&#39;ymax&#39;).text))
        bb = convert((w, h), b)
        out_file.write(str(cls_id) + &quot; &quot; + &quot; &quot;.join([str(a) for a in bb]) + &#39;\n&#39;)


wd = getcwd()
for image_set in sets:
    if not os.path.exists(&#39;../data/labels/&#39;):  
        os.makedirs(&#39;../data/labels/&#39;)  
    image_ids = open(&#39;../data/ImageSets/Main/%s.txt&#39; % (image_set)).read().strip().split() 
    list_file = open(&#39;../data/%s.txt&#39; % (image_set), &#39;w&#39;)  
    for image_id in image_ids:
        list_file.write(&#39;data/images/%s.png\n&#39; % (image_id))  
        convert_annotation(image_id)
    list_file.close()
</code></pre>
<blockquote>
<p>运行两个代码后，文件结构如下:</p>
<p><img src="after.png" alt="数据划分后"></p>
</blockquote>
<p>至此，数据集划分完成。</p>
<h1 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h1><p>在用自己的数据替换掉官方同名文件及文件夹后，打开data文件夹下的coco.yaml，</p>
<pre><code>
# Train/val/test sets as 1) dir: path/to/imgs, 2) file: path/to/imgs.txt, or 3) list: [path/to/imgs1, path/to/imgs2, ..]
# path: ../data/images  # dataset root dir
train: ./data/train.txt  # train images (relative to &#39;path&#39;) 118287 images
val: ./data/val.txt  # train images (relative to &#39;path&#39;) 5000 images
# test: test-dev2017.txt  # 20288 of 40670 images, submit to https://competitions.codalab.org/competitions/20794

# Classes
nc: 4  # number of classes
#: [&#39;single&#39;, &#39;cluster&#39;, &#39;impus&#39;, &#39;dubs&#39;]  # class names
</code></pre>
<p>在models文件夹下打开yolov5s.yaml,</p>
<pre><code>nc: 4  # number of classes
</code></pre>
<p>下载对应的预训练模型</p>
<pre><code>百度网盘链接: https://pan.baidu.com/s/1klUOdDR1tIcsuhnA2fqXdw  密码: bk6r
链接：https://pan.baidu.com/s/1vlTmjNofB5kD3BOaSy4SnA  提取码：gr8v
</code></pre>
<p>下载的预训练模型放置weights文件夹下</p>
<h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><p>打开早前搭建的wsl2环境，拉取pytorch/pytorch:1.9.0-cuda11.1-cudnn8-runtime，</p>
<pre><code>docker pull pytorch/pytorch:1.9.0-cuda11.1-cudnn8-runtime
### 如果是在服务器上运行则是
### docker pull pytorch/pytorch:1.9.0-cuda10.2-cudnn7-devel
</code></pre>
<p>完成后：</p>
<pre><code>docker run -it --rm  --runtime=nvidia --ipc=host -v /mnt/d/yolov5-master/yolov5-master/:/workspace pytorch/pytorch:1.9.0-cuda11.1-cudnn8-runtime
</code></pre>
<p>进入环境后需要执行：</p>
<pre><code>apt update
apt install -y wget libgl1-mesa-glx libglib2.0-dev
pip install -i https://mirror.baidu.com/pypi/simple -r requirements.txt
pip install torchvision --upgrade --force-reinstall -i https://mirror.baidu.com/pypi/simple
</code></pre>
<h2 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h2><pre><code>python train.py --data data/coco.yaml --cfg models/yolov5s.yaml --weights weights/yolov5s.pt --batch-size 32 --epochs 100 --device 0
</code></pre>
<h2 id="测试detect-py"><a href="#测试detect-py" class="headerlink" title="测试detect.py"></a>测试detect.py</h2><p>假设训练结果存在runs/exp32 文件夹下：</p>
<p>修改detect.py</p>
<pre><code>parser.add_argument(&#39;--weights&#39;, nargs=&#39;+&#39;, type=str, default=&#39;runs/train/exp32/weights/best.pt&#39;, help=&#39;model.pt path(s)&#39;)
parser.add_argument(&#39;--source&#39;, type=str, default=&#39;data/xiangyin_images&#39;, help=&#39;file/dir/URL/glob, 0 for webcam&#39;)
</code></pre>
<p>运行结果保存在run/detect文件夹中，可通过修改参数project和name来控制。</p>
<h2 id="test-py"><a href="#test-py" class="headerlink" title="test.py"></a>test.py</h2><p>修改test.py</p>
<pre><code>parser.add_argument(&#39;--weights&#39;, nargs=&#39;+&#39;, type=str, default=&#39;runs/train/exp32/weights/best.pt&#39;, help=&#39;model.pt path(s)&#39;)
</code></pre>
<p>运行结果保存在run/test文件夹中，可通过修改参数project和name来控制。</p>
<p>运行test.py时，可另外运行之前的代码生成test.txt和对应的labels以及ImageSets/Main下的test.txt，</p>
<pre><code>import os
import random

trainval_percent = 1 # 可自行进行调节(设置训练和测试的比例是8：2)
train_percent = 1
xmlfilepath = &#39;Annotations&#39;
txtsavepath = &#39;ImageSets\Main&#39;
total_xml = os.listdir(xmlfilepath)

num = len(total_xml)
list = range(num)
tv = int(num * trainval_percent)
tr = int(tv * train_percent)
trainval = random.sample(list, tv)
val = random.sample(trainval, tr)


# ftrain = open(&#39;ImageSets/Main/train.txt&#39;, &#39;w&#39;)
# fval = open(&#39;ImageSets/Main/val.txt&#39;, &#39;w&#39;)
ftest = open(&#39;ImageSets/Main/test.txt&#39;, &#39;w&#39;)
for i in list:

    name = total_xml[i][:-4] + &#39;\n&#39;
    if i in val:
        ftest.write(name)
        # fval.write(name)
    else:
        ftrain.write(name)

ftest.close()
</code></pre>
<pre><code>import xml.etree.ElementTree as ET
import pickle
import os
from os import listdir, getcwd
from os.path import join

sets = [&#39;test&#39;]

classes = [&#39;single&#39;, &#39;cluster&#39;, &#39;impus&#39;, &#39;dubs&#39;]  # 自己训练的类别


def convert(size, box):
    dw = 1. / size[0]
    dh = 1. / size[1]
    x = (box[0] + box[1]) / 2.0
    y = (box[2] + box[3]) / 2.0
    w = box[1] - box[0]
    h = box[3] - box[2]
    x = x * dw
    w = w * dw
    y = y * dh
    h = h * dh
    return (x, y, w, h)


def convert_annotation(image_id):
    in_file = open(&#39;../data/Annotations/%s.xml&#39; % (image_id))  
    out_file = open(&#39;../data/labels/%s.txt&#39; % (image_id), &#39;w&#39;)  
    tree = ET.parse(in_file)
    root = tree.getroot()
    size = root.find(&#39;size&#39;)
    w = int(size.find(&#39;width&#39;).text)
    h = int(size.find(&#39;height&#39;).text)

    for obj in root.iter(&#39;object&#39;):
        difficult = obj.find(&#39;difficult&#39;).text
        cls = obj.find(&#39;name&#39;).text
        if cls not in classes or int(difficult) == 1:
            continue
        cls_id = classes.index(cls)
        xmlbox = obj.find(&#39;bndbox&#39;)
        b = (float(xmlbox.find(&#39;xmin&#39;).text), float(xmlbox.find(&#39;xmax&#39;).text), float(xmlbox.find(&#39;ymin&#39;).text),
             float(xmlbox.find(&#39;ymax&#39;).text))
        bb = convert((w, h), b)
        out_file.write(str(cls_id) + &quot; &quot; + &quot; &quot;.join([str(a) for a in bb]) + &#39;\n&#39;)


wd = getcwd()
for image_set in sets:
    if not os.path.exists(&#39;../data/labels/&#39;):  
        os.makedirs(&#39;../data/labels/&#39;)  
    image_ids = open(&#39;../data/ImageSets/Main/%s.txt&#39; % (image_set)).read().strip().split() 
    list_file = open(&#39;../data/%s.txt&#39; % (image_set), &#39;w&#39;)  
    for image_id in image_ids:
        list_file.write(&#39;data/images/%s.png\n&#39; % (image_id))  
        convert_annotation(image_id)
    list_file.close()
</code></pre>
<h1 id="docker镜像生成"><a href="#docker镜像生成" class="headerlink" title="docker镜像生成"></a>docker镜像生成</h1><blockquote>
<p>docker commit  容器id 自命名的镜像名</p>
<p>以后直接使用生成的镜像启动容器即可。</p>
</blockquote>
<p>运行以下命令开启docker</p>
<pre><code>docker run -it --rm  --runtime=nvidia --ipc=host -v /mnt/d/yolov5-master/yolov5-master/:/workspace pytorch/pytorch:1.9.0-cuda11.1-cudnn8-runtime###改为刚刚生成的镜像
</code></pre>
<p>​    </p>
