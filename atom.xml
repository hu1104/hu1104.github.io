<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Zongxing</title>
  
  <subtitle>你若安好，便是晴天！</subtitle>
  <link href="https://hu1104.github.io/atom.xml" rel="self"/>
  
  <link href="https://hu1104.github.io/"/>
  <updated>2021-10-27T07:05:31.006Z</updated>
  <id>https://hu1104.github.io/</id>
  
  <author>
    <name>hzx</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Wide_deep</title>
    <link href="https://hu1104.github.io/article/Wide-deep/"/>
    <id>https://hu1104.github.io/article/Wide-deep/</id>
    <published>2021-10-27T07:05:30.000Z</published>
    <updated>2021-10-27T07:05:31.006Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>PNN</title>
    <link href="https://hu1104.github.io/article/PNN/"/>
    <id>https://hu1104.github.io/article/PNN/</id>
    <published>2021-10-27T00:55:13.000Z</published>
    <updated>2021-10-27T07:09:12.747Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;!-- @import &quot;[TOC]&quot; {cmd=&quot;toc&quot; depthFrom=1 depthTo=6 orderedList=false} --&gt;

&lt;!-- code_chunk_output --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a</summary>
        
      
    
    
    
    
  </entry>
  
  <entry>
    <title>deepcrossing</title>
    <link href="https://hu1104.github.io/article/deepcrossing/"/>
    <id>https://hu1104.github.io/article/deepcrossing/</id>
    <published>2021-10-26T08:01:10.000Z</published>
    <updated>2021-10-26T08:35:35.520Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;!-- @import &quot;[TOC]&quot; {cmd=&quot;toc&quot; depthFrom=1 depthTo=6 orderedList=false} --&gt;

&lt;!-- code_chunk_output --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a</summary>
        
      
    
    
    
    
  </entry>
  
  <entry>
    <title>NecuralCF</title>
    <link href="https://hu1104.github.io/article/NeuralCF/"/>
    <id>https://hu1104.github.io/article/NeuralCF/</id>
    <published>2021-10-22T06:45:39.000Z</published>
    <updated>2021-10-26T08:04:22.032Z</updated>
    
    
    <summary type="html">&lt;!-- @import &quot;[TOC]&quot; {cmd=&quot;toc&quot; depthFrom=1 depthTo=6 orderedList=false} --&gt;

&lt;!-- code_chunk_output --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1%E5%8A%A8%E6%9C%BA&quot;&gt;1.动机&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#2%E6%A8%A1%E5%9E%8B%E7%BB%93%E6%9E%84%E5%8F%8A%E5%8E%9F%E7%90%86&quot;&gt;2.模型结构及原理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#3-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0&quot;&gt;3. 代码实现&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- /code_chunk_output --&gt;

&lt;h3 id=&quot;1-动机&quot;&gt;&lt;a href=&quot;#1-动机&quot; class=&quot;headerlink&quot; title=&quot;1.动机&quot;&gt;&lt;/a&gt;1.动机&lt;/h3&gt;&lt;p&gt;在前面的组队学习中，我们学习了最经典的推荐算法，协同过滤。在前深度学习的时代，协同过滤曾经大放异彩，但随着技术的发展，协同过滤相比深度学习模型的弊端就日益显现出来了，因为它是通过直接利用非常稀疏的共现矩阵进行预测的，所以模型的泛化能力非常弱，遇到历史行为非常少的用户，就没法产生准确的推荐结果了。虽然，我们可以通过矩阵分解算法增强它的泛化能力，但因为矩阵分解是利用非常简单的内积方式来处理用户向量和物品向量的交叉问题的，所以，它的拟合能力也比较弱。这该怎么办呢？不是说深度学习模型的拟合能力都很强吗？我们能不能利用深度学习来改进协同过滤算法呢？当然是可以的。2017 年，新加坡国立的研究者就使用深度学习网络来改进了传统的协同过滤算法，取名 NeuralCF（神经网络协同过滤）。NeuralCF 大大提高了协同过滤算法的泛化能力和拟合能力，让这个经典的推荐算法又重新在深度学习时代焕发生机。这章节，我们就一起来学习并实现 NeuralCF！&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>GBDT_LR</title>
    <link href="https://hu1104.github.io/article/GBDT-LR/"/>
    <id>https://hu1104.github.io/article/GBDT-LR/</id>
    <published>2021-10-21T08:34:49.000Z</published>
    <updated>2021-10-22T06:53:18.670Z</updated>
    
    
    <summary type="html">&lt;!-- @import &quot;[TOC]&quot; {cmd=&quot;toc&quot; depthFrom=1 depthTo=6 orderedList=false} --&gt;

&lt;!-- code_chunk_output --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-gbdtlr%E7%AE%80%E4%BB%8B&quot;&gt;1. GBDT+LR简介&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#2-%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92%E6%A8%A1%E5%9E%8B&quot;&gt;2. 逻辑回归模型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#3-gbdt%E6%A8%A1%E5%9E%8B&quot;&gt;3. GBDT模型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#4-gbdtlr%E6%A8%A1%E5%9E%8B&quot;&gt;4. GBDT+LR模型&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- /code_chunk_output --&gt;


&lt;h3 id=&quot;1-GBDT-LR简介&quot;&gt;&lt;a href=&quot;#1-GBDT-LR简介&quot; class=&quot;headerlink&quot; title=&quot;1. GBDT+LR简介&quot;&gt;&lt;/a&gt;1. GBDT+LR简介&lt;/h3&gt;&lt;p&gt;前面介绍的协同过滤和矩阵分解存在的劣势就是仅利用了用户与物品相互行为信息进行推荐， 忽视了用户自身特征， 物品自身特征以及上下文信息等，导致生成的结果往往会比较片面。 而这次介绍的这个模型是2014年由Facebook提出的GBDT+LR模型， 该模型利用GBDT自动进行特征筛选和组合， 进而生成新的离散特征向量， 再把该特征向量当做LR模型的输入， 来产生最后的预测结果， 该模型能够综合利用用户、物品和上下文等多种不同的特征， 生成较为全面的推荐结果， 在CTR点击率预估场景下使用较为广泛。&lt;/p&gt;
&lt;p&gt;下面首先会介绍逻辑回归和GBDT模型各自的原理及优缺点， 然后介绍GBDT+LR模型的工作原理和细节。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>FM</title>
    <link href="https://hu1104.github.io/article/FM/"/>
    <id>https://hu1104.github.io/article/FM/</id>
    <published>2021-10-21T07:32:07.000Z</published>
    <updated>2021-10-22T02:45:50.880Z</updated>
    
    
    <summary type="html">&lt;!-- @import &quot;[TOC]&quot; {cmd=&quot;toc&quot; depthFrom=1 depthTo=6 orderedList=false} --&gt;

&lt;!-- code_chunk_output --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-fm%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%BC%95%E5%85%A5&quot;&gt;1. FM模型的引入&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#11-%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92%E6%A8%A1%E5%9E%8B%E5%8F%8A%E5%85%B6%E7%BC%BA%E7%82%B9&quot;&gt;1.1 逻辑回归模型及其缺点&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#12-%E4%BA%8C%E9%98%B6%E4%BA%A4%E5%8F%89%E9%A1%B9%E7%9A%84%E8%80%83%E8%99%91%E5%8F%8A%E6%94%B9%E8%BF%9B&quot;&gt;1.2 二阶交叉项的考虑及改进&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#2-fm%E5%85%AC%E5%BC%8F%E7%9A%84%E7%90%86%E8%A7%A3&quot;&gt;2. FM公式的理解&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#3-fm%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%BA%94%E7%94%A8&quot;&gt;3. FM模型的应用&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- /code_chunk_output --&gt;

&lt;h3 id=&quot;1-FM模型的引入&quot;&gt;&lt;a href=&quot;#1-FM模型的引入&quot; class=&quot;headerlink&quot; title=&quot;1. FM模型的引入&quot;&gt;&lt;/a&gt;1. FM模型的引入&lt;/h3&gt;&lt;h4 id=&quot;1-1-逻辑回归模型及其缺点&quot;&gt;&lt;a href=&quot;#1-1-逻辑回归模型及其缺点&quot; class=&quot;headerlink&quot; title=&quot;1.1 逻辑回归模型及其缺点&quot;&gt;&lt;/a&gt;1.1 逻辑回归模型及其缺点&lt;/h4&gt;&lt;p&gt;FM模型其实是一种思路，具体的应用稍少。一般来说做推荐CTR预估时最简单的思路就是将特征做线性组合（逻辑回归LR），传入sigmoid中得到一个概率值，本质上这就是一个线性模型，因为sigmoid是单调增函数不会改变里面的线性模型的CTR预测顺序，因此逻辑回归模型效果会比较差。也就是LR的缺点有：&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>MF</title>
    <link href="https://hu1104.github.io/article/MF/"/>
    <id>https://hu1104.github.io/article/MF/</id>
    <published>2021-10-21T03:07:19.000Z</published>
    <updated>2021-10-21T08:42:22.626Z</updated>
    
    
    <summary type="html">&lt;!-- @import &quot;[TOC]&quot; {cmd=&quot;toc&quot; depthFrom=1 depthTo=6 orderedList=false} --&gt;

&lt;!-- code_chunk_output --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-%E9%9A%90%E8%AF%AD%E4%B9%89%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%9F%A9%E9%98%B5%E5%88%86%E8%A7%A3&quot;&gt;1. 隐语义模型与矩阵分解&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#2-%E9%9A%90%E8%AF%AD%E4%B9%89%E6%A8%A1%E5%9E%8B&quot;&gt;2. 隐语义模型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#3%E7%9F%A9%E9%98%B5%E5%88%86%E8%A7%A3%E7%9A%84%E5%8E%9F%E7%90%86&quot;&gt;3.矩阵分解的原理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#4%E7%9F%A9%E9%98%B5%E5%88%86%E8%A7%A3%E7%9A%84%E6%B1%82%E8%A7%A3funk-svd&quot;&gt;4.矩阵分解的求解——Funk-SVD&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#5-%E7%BC%96%E7%A8%8B%E5%AE%9E%E7%8E%B0&quot;&gt;5. 编程实现&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#6-%E4%BC%98%E7%BC%BA%E7%82%B9&quot;&gt;6. 优缺点&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- /code_chunk_output --&gt;

&lt;h3 id=&quot;1-隐语义模型与矩阵分解&quot;&gt;&lt;a href=&quot;#1-隐语义模型与矩阵分解&quot; class=&quot;headerlink&quot; title=&quot;1. 隐语义模型与矩阵分解&quot;&gt;&lt;/a&gt;1. 隐语义模型与矩阵分解&lt;/h3&gt;&lt;p&gt;协同过滤算法的特点就是完全没有利用到物品本身或者是用户自身的属性， 仅仅利用了用户与物品的交互信息就可以实现推荐，是一个可解释性很强， 非常直观的模型， 但是也存在一些问题， 第一个就是处理稀疏矩阵的能力比较弱， 所以为了使得协同过滤更好处理稀疏矩阵问题， 增强泛化能力， 从协同过滤中衍生出矩阵分解模型(Matrix Factorization,MF)或者叫隐语义模型, 两者差不多说的一个意思， 就是在协同过滤共现矩阵的基础上， 使用更稠密的隐向量表示用户和物品， 挖掘用户和物品的隐含兴趣和隐含特征， 在一定程度上弥补协同过滤模型处理稀疏矩阵能力不足的问题。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>CF</title>
    <link href="https://hu1104.github.io/article/CF/"/>
    <id>https://hu1104.github.io/article/CF/</id>
    <published>2021-10-20T02:36:47.000Z</published>
    <updated>2021-10-21T08:42:19.788Z</updated>
    
    
    <summary type="html">&lt;!-- @import &quot;[TOC]&quot; {cmd=&quot;toc&quot; depthFrom=1 depthTo=6 orderedList=false} --&gt;

&lt;!-- code_chunk_output --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-%E5%8D%8F%E8%B0%83%E8%BF%87%E6%BB%A4%E7%AE%97%E6%B3%95&quot;&gt;1. 协调过滤算法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#2-%E7%9B%B8%E4%BC%BC%E6%80%A7%E5%BA%A6%E9%87%8F%E6%96%B9%E6%B3%95&quot;&gt;2. 相似性度量方法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#3-%E5%9F%BA%E4%BA%8E%E7%94%A8%E6%88%B7%E7%9A%84%E5%8D%8F%E5%90%8C%E8%BF%87%E6%BB%A4&quot;&gt;3. 基于用户的协同过滤&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#4-%E7%BC%96%E7%A8%8B%E5%AE%9E%E7%8E%B0&quot;&gt;4. 编程实现&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#5-usercf-%E4%BC%98%E7%BC%BA%E7%82%B9&quot;&gt;5. UserCF 优缺点&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#6-%E7%AE%97%E6%B3%95%E8%AF%84%E4%BC%B0&quot;&gt;6. 算法评估&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#7%E5%8D%8F%E5%90%8C%E8%BF%87%E6%BB%A4%E7%AE%97%E6%B3%95%E7%9A%84%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90&quot;&gt;7.协同过滤算法的问题分析&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- /code_chunk_output --&gt;

&lt;h3 id=&quot;1-协调过滤算法&quot;&gt;&lt;a href=&quot;#1-协调过滤算法&quot; class=&quot;headerlink&quot; title=&quot;1. 协调过滤算法&quot;&gt;&lt;/a&gt;1. 协调过滤算法&lt;/h3&gt;&lt;p&gt;所谓协同过滤， 基本思想是根据用户之前的喜好以及其他兴趣相近的用户的选择来给用户推荐物品(基于对用户历史行为数据的挖掘发现用户的喜好偏向， 并预测用户可能喜好的产品进行推荐)，一般是仅仅基于用户的行为数据（评价、购买、下载等）, 而不依赖于项的任何附加信息（物品自身特征）或者用户的任何附加信息（年龄， 性别等）。&lt;br&gt;&lt;br&gt;&lt;br&gt;目前应用比较广泛的协同过滤算法是基于邻域的方法， 而这种方法主要有下面两种算法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基于用户的协同过滤算法(UserCF): 给用户推荐和他兴趣相似的其他用户喜欢的产品&lt;/li&gt;
&lt;li&gt;基于物品的协同过滤算法(ItemCF): 给用户推荐和他之前喜欢的物品相似的物品&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不管是UserCF还是ItemCF算法， 非常重要的步骤之一就是计算用户和用户或者物品和物品之间的相似度， 所以下面先整理常用的相似性度量方法， 然后再对每个算法的具体细节进行展开。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>RS</title>
    <link href="https://hu1104.github.io/article/RS/"/>
    <id>https://hu1104.github.io/article/RS/</id>
    <published>2021-10-18T05:37:56.000Z</published>
    <updated>2021-10-20T02:42:18.623Z</updated>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;%E5%8F%91%E5%B1%95%E5%9B%BE1.png&quot; alt=&quot;rs发展历程1&quot;&gt;&lt;br&gt;&lt;img src=&quot;%E5%8F%91%E5%B1%95%E5%9B%BE2.png&quot; alt=&quot;rs发展历程2&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>git_learn</title>
    <link href="https://hu1104.github.io/article/git_learn/"/>
    <id>https://hu1104.github.io/article/git_learn/</id>
    <published>2021-09-09T08:41:08.000Z</published>
    <updated>2021-10-19T03:13:07.578Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;&lt;img src=&quot;image-20210909164119386.png&quot; alt=&quot;image-20210909164119386&quot; title=&quot;dsfsdf&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;image-20210909165936257.png&quot;</summary>
        
      
    
    
    
    
  </entry>
  
  <entry>
    <title>anchor_free_or_anchor_based</title>
    <link href="https://hu1104.github.io/article/anchor-free-or-anchor-based/"/>
    <id>https://hu1104.github.io/article/anchor-free-or-anchor-based/</id>
    <published>2021-09-07T07:52:54.000Z</published>
    <updated>2021-09-07T07:52:54.784Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>algorithm</title>
    <link href="https://hu1104.github.io/article/algorithm/"/>
    <id>https://hu1104.github.io/article/algorithm/</id>
    <published>2021-09-07T01:42:30.000Z</published>
    <updated>2021-09-07T01:42:30.249Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>上采样方法</title>
    <link href="https://hu1104.github.io/article/%E4%B8%8A%E9%87%87%E6%A0%B7%E6%96%B9%E6%B3%95/"/>
    <id>https://hu1104.github.io/article/%E4%B8%8A%E9%87%87%E6%A0%B7%E6%96%B9%E6%B3%95/</id>
    <published>2021-09-06T07:48:43.000Z</published>
    <updated>2021-10-19T02:54:08.395Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;pixelshuffle&quot;&gt;&lt;a href=&quot;#pixelshuffle&quot; class=&quot;headerlink&quot; title=&quot;pixelshuffle&quot;&gt;&lt;/a&gt;pixelshuffle&lt;a href=&quot;#pixelshuffle&quot;</summary>
        
      
    
    
    
    
  </entry>
  
  <entry>
    <title>LN_BN</title>
    <link href="https://hu1104.github.io/article/LN-BN/"/>
    <id>https://hu1104.github.io/article/LN-BN/</id>
    <published>2021-09-03T01:40:40.000Z</published>
    <updated>2021-10-19T02:54:59.423Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;LN：Layer Normalization，LN是“横”着来的，对一个样本，不同的神经元neuron间做归一化。&lt;/p&gt;
&lt;p&gt;BN：Batch Normalization，BN是“竖”着来的，各个维度做归一化，所以与batch size有关系。&lt;/p&gt;
&lt;p&gt;&lt;img</summary>
        
      
    
    
    
    
  </entry>
  
  <entry>
    <title>all_CN</title>
    <link href="https://hu1104.github.io/article/all-CN/"/>
    <id>https://hu1104.github.io/article/all-CN/</id>
    <published>2021-09-03T01:40:26.000Z</published>
    <updated>2021-10-19T02:56:11.000Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;深度可分离卷积&quot;&gt;&lt;a href=&quot;#深度可分离卷积&quot; class=&quot;headerlink&quot; title=&quot;深度可分离卷积&quot;&gt;&lt;/a&gt;深度可分离卷积&lt;/h1&gt;&lt;p&gt;假设输入是$D_{f^i} * D_{f^i} * M$ ,输出图大小是$D_{f^o}*D_{f^o}&lt;em&gt;N$, 卷积核大小是$D_k&lt;/em&gt;D_k$&lt;/p&gt;
&lt;h2 id=&quot;普通卷积操作&quot;&gt;&lt;a href=&quot;#普通卷积操作&quot; class=&quot;headerlink&quot; title=&quot;普通卷积操作&quot;&gt;&lt;/a&gt;普通卷积操作&lt;/h2&gt;&lt;p&gt;输入图在经过卷积核（$D_k&lt;em&gt;D_k&lt;/em&gt;M$）后输出为目标输出大小，但此时仅为$D_{f^o}*D_{f^o} * 1$ ,需要$N$个这样的操作才能得到目标特征图。&lt;/p&gt;
&lt;p&gt;此时所需要的计算量有$D_{f^o}&lt;em&gt;D_{f^o}&lt;em&gt;D_k&lt;/em&gt;D_k&lt;/em&gt;M*N$。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>deeplearning</title>
    <link href="https://hu1104.github.io/article/deeplearning/"/>
    <id>https://hu1104.github.io/article/deeplearning/</id>
    <published>2021-08-31T05:55:09.000Z</published>
    <updated>2021-08-31T08:43:15.261Z</updated>
    
    
    <summary type="html">Welcome to my blog, enter password to read.</summary>
    
    
    
    
    <category term="加密" scheme="https://hu1104.github.io/tags/%E5%8A%A0%E5%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>mmdetection</title>
    <link href="https://hu1104.github.io/article/mmdetection/"/>
    <id>https://hu1104.github.io/article/mmdetection/</id>
    <published>2021-08-30T07:33:17.000Z</published>
    <updated>2021-08-30T07:59:05.195Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;参考资料&quot;&gt;&lt;a href=&quot;#参考资料&quot; class=&quot;headerlink&quot; title=&quot;参考资料&quot;&gt;&lt;/a&gt;参考资料&lt;a href=&quot;#参考资料&quot; class=&quot;header-anchor&quot;&gt;#&lt;/a&gt;&lt;/h1&gt;&lt;p&gt;&lt;a</summary>
        
      
    
    
    
    
  </entry>
  
  <entry>
    <title>yolox训练自定义数据集</title>
    <link href="https://hu1104.github.io/article/yolox%E8%AE%AD%E7%BB%83%E8%87%AA%E5%AE%9A%E4%B9%89%E6%95%B0%E6%8D%AE%E9%9B%86/"/>
    <id>https://hu1104.github.io/article/yolox%E8%AE%AD%E7%BB%83%E8%87%AA%E5%AE%9A%E4%B9%89%E6%95%B0%E6%8D%AE%E9%9B%86/</id>
    <published>2021-08-30T06:13:04.000Z</published>
    <updated>2021-10-19T02:57:16.478Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;环境配置&quot;&gt;&lt;a href=&quot;#环境配置&quot; class=&quot;headerlink&quot; title=&quot;环境配置&quot;&gt;&lt;/a&gt;环境配置&lt;/h1&gt;&lt;p&gt; 第一步：安装YOLOX&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git clone git@github.com:Megvii-BaseDetection/YOLOX.git&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cd YOLOX&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;pip3 install -U pip &amp;amp;&amp;amp; pip3 install -r requirements.txt&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;pip3 install -v -e .  # or  python3 setup.py develop&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>python_base</title>
    <link href="https://hu1104.github.io/article/python-base/"/>
    <id>https://hu1104.github.io/article/python-base/</id>
    <published>2021-08-30T02:18:47.000Z</published>
    <updated>2021-08-30T07:20:16.023Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;initpy&quot;&gt;&lt;a href=&quot;#init-py&quot; class=&quot;headerlink&quot; title=&quot;init.py&quot;&gt;&lt;/a&gt;&lt;strong&gt;init&lt;/strong&gt;.py&lt;a href=&quot;#initpy&quot;</summary>
        
      
    
    
    
    
  </entry>
  
  <entry>
    <title>logging</title>
    <link href="https://hu1104.github.io/article/logging/"/>
    <id>https://hu1104.github.io/article/logging/</id>
    <published>2021-08-27T05:33:03.000Z</published>
    <updated>2021-08-30T07:19:53.691Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;按天生成日志&quot;&gt;&lt;a href=&quot;#按天生成日志&quot; class=&quot;headerlink&quot; title=&quot;按天生成日志&quot;&gt;&lt;/a&gt;按天生成日志&lt;a href=&quot;#按天生成日志&quot; class=&quot;header-anchor&quot;&gt;#&lt;/a&gt;&lt;/h1&gt;&lt;figure</summary>
        
      
    
    
    
    
  </entry>
  
</feed>
